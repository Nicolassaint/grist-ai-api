import openai
from typing import Dict, Any, Optional
from ..models.message import Message, ConversationHistory
from ..utils.logging import AgentLogger
from ..utils.conversation_formatter import (
    format_conversation_history,
    should_include_conversation_history,
)
from ..grist.sql_runner import GristSQLRunner
import time


class AnalysisAgent:
    """Agent d'analyse qui produit des insights √† partir des donn√©es et du contexte"""

    def __init__(self, openai_client: openai.AsyncOpenAI, model: str = "gpt-4"):
        self.client = openai_client
        self.model = model
        self.logger = AgentLogger("analysis_agent")

        self.analysis_prompt_template = """Tu es un assistant d'analyse de donn√©es. Donne une interpr√©tation COURTE et DIRECTE des r√©sultats.

HISTORIQUE DE CONVERSATION:
{conversation_history}

QUESTION: {user_question}

R√âSULTATS SQL:
{sql_results}

INSTRUCTION: 
Donne une r√©ponse de 1-2 phrases maximum qui explique ce que montrent ces donn√©es de mani√®re simple et utile.
Ne fais pas de sections, pas de recommandations complexes, juste l'essentiel.

Exemple de format attendu:
"La moyenne d'√¢ge est de 35 ans, ce qui indique une population majoritairement adulte en milieu de carri√®re."
"""

    async def process_message(
        self,
        user_message: str,
        conversation_history: ConversationHistory,
        sql_query: str,
        sql_results: Dict[str, Any],
        request_id: str,
    ) -> str:
        """
        Traite un message n√©cessitant une analyse de donn√©es

        Args:
            user_message: Question de l'utilisateur
            conversation_history: Historique de la conversation
            sql_query: Requ√™te SQL qui a √©t√© ex√©cut√©e
            sql_results: R√©sultats de la requ√™te SQL
            request_id: ID de la requ√™te pour le logging

        Returns:
            str: R√©ponse d'analyse
        """
        start_time = time.time()

        self.logger.log_agent_start(request_id, user_message)

        try:
            # Formatage des donn√©es pour l'analyse
            formatted_results = self._format_data_for_analysis(sql_results)
            numeric_summary = self._generate_numeric_summary(sql_results)

            # Gestion intelligente des donn√©es vides vs erreurs
            if not sql_results.get("success"):
                # Vraie erreur SQL
                return self._handle_sql_error(user_message, sql_results)
            elif not sql_results.get("data") or len(sql_results["data"]) == 0:
                # Requ√™te r√©ussie mais sans donn√©es - cas normal
                return self._handle_empty_results(user_message, sql_query)

            # G√©n√©ration de l'analyse via IA avec des donn√©es disponibles
            analysis_response = await self._generate_analysis(
                user_message,
                conversation_history,
                sql_query,
                formatted_results,
                numeric_summary,
                request_id,
            )

            execution_time = time.time() - start_time
            self.logger.log_agent_response(
                request_id, analysis_response, execution_time
            )

            return analysis_response

        except Exception as e:
            execution_time = time.time() - start_time
            self.logger.error(
                f"Erreur lors de l'analyse: {str(e)}",
                request_id=request_id,
                execution_time=execution_time,
            )
            return self._get_fallback_analysis(user_message, sql_results)

    async def _generate_analysis(
        self,
        user_message: str,
        conversation_history: ConversationHistory,
        sql_query: str,
        formatted_results: str,
        numeric_summary: str,
        request_id: str,
    ) -> str:
        """G√©n√®re l'analyse via l'IA"""

        # Historique de conversation format√© (paires user/assistant compl√®tes)
        conversation_context = (
            format_conversation_history(conversation_history, max_pairs=2)
            if should_include_conversation_history("analysis")
            else "Aucun historique de conversation"
        )

        # Construction du prompt simplifi√©
        prompt = self.analysis_prompt_template.format(
            conversation_history=conversation_context,
            user_question=user_message,
            sql_results=formatted_results,
        )

        try:
            # ü§ñ Log lisible de la requ√™te IA
            self.logger.log_ai_request(
                model=self.model,
                messages_count=1,
                max_tokens=100,
                request_id=request_id,
                prompt_preview=prompt,
            )

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=100,  # Limit√© pour forcer la concision
                temperature=0.1,  # Tr√®s peu de cr√©ativit√©, plus factuel
            )

            analysis = response.choices[0].message.content.strip()

            # ü§ñ Log lisible de la r√©ponse IA
            tokens_used = (
                getattr(response.usage, "total_tokens", None)
                if hasattr(response, "usage")
                else None
            )
            self.logger.log_ai_response(
                model=self.model,
                tokens_used=tokens_used,
                success=True,
                request_id=request_id,
                response_preview=analysis,
            )

            self.logger.info(
                "Analyse g√©n√©r√©e avec succ√®s",
                request_id=request_id,
                analysis_length=len(analysis),
            )

            return analysis

        except Exception as e:
            self.logger.error(
                f"Erreur lors de la g√©n√©ration d'analyse: {str(e)}",
                request_id=request_id,
            )
            return self._get_fallback_analysis(user_message, {"data": []})

    def _format_data_for_analysis(self, sql_results: Dict[str, Any]) -> str:
        """Formate les donn√©es SQL pour l'analyse"""
        if not sql_results.get("success") or not sql_results.get("data"):
            return "Aucune donn√©e disponible"

        data = sql_results["data"]
        columns = sql_results.get("columns", [])

        # Limitation pour √©viter des prompts trop longs
        max_rows = 20

        formatted = f"Donn√©es ({len(data)} ligne{'s' if len(data) > 1 else ''}):\n\n"

        if columns:
            # Format tabulaire
            formatted += "| " + " | ".join(columns) + " |\n"
            formatted += "| " + " | ".join(["---"] * len(columns)) + " |\n"

            for i, row in enumerate(data[:max_rows]):
                row_values = []
                for col in columns:
                    value = str(row.get(col, ""))
                    # Limiter la longueur pour la lisibilit√©
                    if len(value) > 30:
                        value = value[:27] + "..."
                    row_values.append(value)
                formatted += "| " + " | ".join(row_values) + " |\n"

            if len(data) > max_rows:
                formatted += f"\n... et {len(data) - max_rows} autres lignes.\n"
        else:
            # Fallback sans colonnes
            formatted += str(data[:max_rows])

        return formatted

    def _generate_numeric_summary(self, sql_results: Dict[str, Any]) -> str:
        """G√©n√®re un r√©sum√© num√©rique des donn√©es"""
        if not sql_results.get("success") or not sql_results.get("data"):
            return "Aucune donn√©e num√©rique disponible"

        data = sql_results["data"]
        columns = sql_results.get("columns", [])

        summary_parts = [f"Total des lignes: {len(data)}"]

        # Analyse des colonnes num√©riques
        numeric_stats = {}
        for col in columns:
            numeric_values = []
            for row in data:
                try:
                    value = float(row.get(col, 0))
                    numeric_values.append(value)
                except (ValueError, TypeError):
                    continue

            if numeric_values and len(numeric_values) > 0:
                numeric_stats[col] = {
                    "count": len(numeric_values),
                    "sum": sum(numeric_values),
                    "avg": sum(numeric_values) / len(numeric_values),
                    "min": min(numeric_values),
                    "max": max(numeric_values),
                }

        if numeric_stats:
            summary_parts.append("\nStatistiques par colonne:")
            for col, stats in numeric_stats.items():
                summary_parts.append(
                    f"- {col}: Total={stats['sum']:.2f}, "
                    f"Moyenne={stats['avg']:.2f}, "
                    f"Min={stats['min']:.2f}, "
                    f"Max={stats['max']:.2f}"
                )

        return "\n".join(summary_parts)

    def _handle_no_data_scenario(
        self, user_message: str, sql_results: Dict[str, Any]
    ) -> str:
        """G√®re le cas o√π il n'y a pas de donn√©es √† analyser"""

        error_msg = sql_results.get("error", "") if sql_results else ""

        response_parts = [
            "## Analyse impossible",
            "",
            "Je ne peux pas effectuer d'analyse car aucune donn√©e n'est disponible.",
        ]

        if error_msg:
            response_parts.extend(
                [
                    "",
                    f"**Erreur rencontr√©e :** {error_msg}",
                ]
            )

        response_parts.extend(
            [
                "",
                "### Suggestions :",
                "‚Ä¢ V√©rifiez que les donn√©es existent dans vos tables Grist",
                "‚Ä¢ Reformulez votre question pour √™tre plus sp√©cifique",
                "‚Ä¢ Assurez-vous que les crit√®res de filtrage ne sont pas trop restrictifs",
                "",
                "**Exemple :** Au lieu de 'Analyse les ventes de janvier 2025', "
                "essayez 'Montre-moi toutes les ventes' d'abord.",
            ]
        )

        return "\n".join(response_parts)

    def _handle_sql_error(self, user_message: str, sql_results: Dict[str, Any]) -> str:
        """G√®re les vraies erreurs SQL (√©chec de requ√™te)"""

        error_msg = sql_results.get("error", "Erreur SQL inconnue")

        response_parts = [
            "## ‚ùå Erreur d'ex√©cution SQL",
            "",
            "La requ√™te SQL a √©chou√© et ne peut pas √™tre analys√©e.",
            "",
            f"**Erreur technique :** {error_msg}",
            "",
            "### Suggestions pour r√©soudre :",
            "‚Ä¢ V√©rifiez vos permissions d'acc√®s aux donn√©es",
            "‚Ä¢ Reformulez votre question avec des termes plus simples",
            "‚Ä¢ Assurez-vous que les tables et colonnes existent",
            "‚Ä¢ Contactez l'administrateur si l'erreur persiste",
        ]

        return "\n".join(response_parts)

    def _handle_empty_results(self, user_message: str, sql_query: str) -> str:
        """G√®re les r√©sultats vides (requ√™te r√©ussie mais aucune donn√©e)"""

        response_parts = [
            "## üìä Analyse des r√©sultats",
            "",
            "La requ√™te s'est ex√©cut√©e avec succ√®s mais n'a retourn√© aucune donn√©e.",
            "",
            "### üîç Que signifie ce r√©sultat ?",
            "",
            "**C'est normal !** Cela peut signifier que :",
            "‚Ä¢ Aucune donn√©e ne correspond √† vos crit√®res de recherche",
            "‚Ä¢ Les filtres appliqu√©s sont trop restrictifs",
            "‚Ä¢ Les donn√©es recherch√©es n'existent pas encore dans votre base",
            "",
            "### üí° Suggestions pour approfondir :",
            "‚Ä¢ **√âlargir la recherche :** Essayez avec des crit√®res moins restrictifs",
            "‚Ä¢ **V√©rifier les donn√©es :** Demandez un aper√ßu g√©n√©ral de vos tables",
            "‚Ä¢ **Reformuler :** Posez la question diff√©remment",
            "",
            "**Exemples de questions plus larges :**",
            "‚Ä¢ 'Montre-moi un aper√ßu de toutes les donn√©es'",
            "‚Ä¢ 'Quelles sont les donn√©es disponibles dans cette table ?'",
            "‚Ä¢ 'Combien de lignes contient cette table ?'",
        ]

        return "\n".join(response_parts)

    def _suggest_alternative_analysis(self, user_message: str) -> str:
        """Sugg√®re des analyses alternatives quand les donn√©es sont insuffisantes"""

        suggestions = [
            "## Donn√©es insuffisantes pour l'analyse",
            "",
            "Les donn√©es r√©cup√©r√©es sont vides ou insuffisantes pour une analyse significative.",
            "",
            "### Suggestions d'analyses alternatives :",
            "‚Ä¢ **Vue d'ensemble :** 'Montre-moi un aper√ßu de toutes les donn√©es'",
            "‚Ä¢ **Par p√©riode :** 'Donn√©es des 30 derniers jours'",
            "‚Ä¢ **Par cat√©gorie :** 'R√©partition par type/statut/r√©gion'",
            "‚Ä¢ **Tendances :** '√âvolution sur les 6 derniers mois'",
            "",
            "Reformulez votre question en √©tant plus large dans vos crit√®res, "
            "puis nous pourrons affiner l'analyse ensemble.",
        ]

        return "\n".join(suggestions)

    def _get_fallback_analysis(
        self, user_message: str, sql_results: Dict[str, Any]
    ) -> str:
        """Analyse de secours en cas d'erreur"""

        row_count = len(sql_results.get("data", [])) if sql_results else 0

        if row_count == 0:
            return "Aucune donn√©e trouv√©e pour cette requ√™te."

        return f"J'ai trouv√© {row_count} r√©sultat{'s' if row_count > 1 else ''} mais je ne peux pas les analyser pour le moment."
